<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title></title>

    <!-- import the d3 library -->
    <script type="text/javascript" src="lib/d3.v5.min.js"></script>

    <!-- <script src="map.js"></script> -->

    <!-- style sheet -->
    <link rel="stylesheet" type="text/css" href="style.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
    />
  </head>

  <body>
    <div id="contentContainer">
      <div id="map-container">
        <svg id="scene">...</svg>
        <div id="year-slider-container">
          <button id="play-button"><i class="fas fa-play"></i></button>

          <input
            type="range"
            id="year-slider"
            min="1900"
            max="2023"
            value="2023"
          />
          <span id="selected-year">2023</span>
        </div>
      </div>

      <div id="albumTableContainer">
        <h3 id="countryName">Albums</h3>
        <table id="albumTable">
          <thead>
            <tr>
              <th>Title</th>
              <th>Publication Date</th>
              <th>Length</th>
            </tr>
          </thead>
          <tbody id="albumList">
            <!-- Album rows will be populated here -->
          </tbody>
        </table>
      </div>
    </div>

    <script>
      let lastHoveredCountry = null;

      let width = 800,
        height = 600,
        svg = d3.select("#scene").attr("width", width).attr("height", height);

      let projection = d3
        .geoMercator()
        .scale(150) // adjusted from 200
        .translate([width / 2, height / 2]);

      // Load external data
      Promise.all([
        d3.json("data/custom.geo.json"),
        d3.csv(
          // "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world_population.csv"
          "data/wasabi_albums_pre-processed.csv"
        ),
      ]).then((files) => {
        const groupedByCountry = files[1].reduce((accumulator, record) => {
          if (!accumulator[record.country]) {
            accumulator[record.country] = [];
          }
          accumulator[record.country].push(record);
          return accumulator;
        }, {});

        const currentAlbums = files[1];

        const counts = Object.values(groupedByCountry);
        const minCount = Math.min(...counts);
        const maxCount = Math.max(...counts);

        const numThresholds = 6; // 7 colors => 6 thresholds
        const step = (maxCount - minCount) / numThresholds;
        const domain = Array.from(
          { length: numThresholds },
          (_, i) => minCount + i * step
        );

        let topo = files[0],
          data = files[1];
        let colorScale = d3
          .scaleThreshold()
          // .domain(domain)
          .domain([1, 10, 100, 1000, 10000, 100000])
          .range(d3.schemeBlues[7]);

        // create a tooltip
        var Tooltip = d3
          .select("body")
          .append("div")
          .style("opacity", 0)
          .attr("class", "tooltip")
          .style("background-color", "white")
          .style("border", "solid")
          .style("border-width", "2px")
          .style("border-radius", "5px")
          .style("padding", "5px");

        function updateAlbumTable(countryName, albums) {
          // Set country name as table title
          d3.select("#countryName").text(`Albums from ${countryName}`);

          // Populate the table
          let tbody = d3.select("#albumList");
          tbody.html(""); // Clear existing rows

          albums.forEach((album) => {
            let row = tbody.append("tr");
            row.append("td").text(album.title);
            row.append("td").text(album.publicationDate || "Unknown");
            row.append("td").text(album.length || "Unknown");
          });
        }

        // Three function that changes the tooltip when user hover / move / leave a cell
        var mouseover = function (d) {
          Tooltip.style("opacity", 1);
          d3.select(this).style("stroke", "black").style("opacity", 1);

          const selectedYear = +d3.select("#year-slider").node().value;
          lastHoveredCountry = d.properties;

          // Filter albums by the selected year
          let albums = getValue(d.properties).filter(
            (album) => +album.publicationDate === selectedYear
          );

          updateAlbumTable(d.properties.name, albums);
        };

        var mousemove = function (d) {
          // Get the correct value for the current country
          let value = getValue(d.properties).length;

          Tooltip.html(value + " albums")
            .style("left", d3.event.pageX + 10 + "px")
            .style("top", d3.event.pageY - 28 + "px");
        };

        var mouseleave = function (d) {
          Tooltip.style("opacity", 0);
          d3.select(this).style("stroke", "none").style("opacity", 0.8);
        };

        function updateTable(albums) {
          // Assuming you have an existing table body selection:
          const tbody = d3.select("#albums-table tbody");

          // Clear the table
          tbody.html("");

          // Append rows for each album
          albums.forEach((album) => {
            const row = tbody.append("tr");

            row.append("td").text(album.title);
            row.append("td").text(album.country);
            row.append("td").text(album.publicationDate);
            row.append("td").text(album.length);
          });
        }

        // // Draw the map (this part remains unchanged)
        const mapGroup = svg.append("g");

        function getTotalAlbums(countryId) {
          return (
            groupedByCountry[countryId.fips_10] ||
            groupedByCountry[countryId.iso_a2] ||
            groupedByCountry[countryId.iso_a2_eh] ||
            groupedByCountry[countryId.wb_a2] ||
            []
          );
        }

        mapGroup
          .selectAll("path")
          .data(topo.features)
          .enter()
          .append("path")
          .attr("d", d3.geoPath().projection(projection))
          .attr("fill", (d) => colorScale(getTotalAlbums(d.properties).length))
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave);

        // Modified getValue function to consider the selected year
        function getValue(countryId) {
          const selectedYear = +d3.select("#year-slider").node().value;
          const allAlbums =
            groupedByCountry[countryId.fips_10] ||
            groupedByCountry[countryId.iso_a2] ||
            groupedByCountry[countryId.iso_a2_eh] ||
            groupedByCountry[countryId.wb_a2] ||
            [];
          return allAlbums.filter(
            (album) => +album.publicationDate === selectedYear
          );
        }

        d3.select("#year-slider").on("input", function () {
          const selectedYear = +this.value;
          d3.select("#selected-year").text(selectedYear);

          const albumsForSelectedYear = currentAlbums.filter((album) => {
            const albumYear = +album.publicationDate;
            return albumYear === selectedYear;
          });

          mapGroup
            .selectAll("path")
            .attr("fill", (d) => colorScale(getValue(d.properties).length));
          updateTable(albumsForSelectedYear);

          // If a country has been hovered on, update the table for that country
          if (lastHoveredCountry) {
            let albums = getValue(lastHoveredCountry).filter(
              (album) => +album.publicationDate === selectedYear
            );

            updateAlbumTable(lastHoveredCountry.name, albums);
          }
        });

        let interval;
        let playing = false;

        d3.select("#play-button").on("click", function () {
          if (playing) {
            clearInterval(interval); // Stop the playback
            d3.select(this).text("Play"); // Update button text
          } else {
            const slider = d3.select("#year-slider").node();
            const maxYear = +slider.getAttribute("max");

            interval = setInterval(() => {
              let currentYear = +slider.value;
              currentYear++; // Increment year

              if (currentYear > maxYear) {
                clearInterval(interval); // Stop at maxYear
                d3.select("#play-button").text("Play");
              } else {
                slider.value = currentYear;
                d3.select("#selected-year").text(currentYear);
                // Trigger the input event to update the map and table
                slider.dispatchEvent(new Event("input"));
              }
            }, 350);

            d3.select(this).text("Pause"); // Update button text
          }

          playing = !playing; // Toggle playing state
        });

        // Extracting years from the dataset
        let years = files[1]
          .map((record) => +record.publicationDate)
          .filter((year) => year !== 0); // Exclude the year 0

        // Determine the min and max years
        const minYear = Math.min(...years);
        const maxYear = Math.max(...years);

        d3.select("#year-slider")
          .attr("min", minYear)
          .attr("max", maxYear)
          .attr("value", maxYear - 20); // Setting the initial value of the slider

        d3.select("#selected-year").text(maxYear - 20);
      });
    </script>
  </body>
</html>
