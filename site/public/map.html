<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title></title>

    <!-- import the d3 library -->
    <script type="text/javascript" src="lib/d3.v5.min.js"></script>

    <!-- <script src="map.js"></script> -->

    <!-- style sheet -->
    <link rel="stylesheet" type="text/css" href="style.css" />
  </head>

  <body>
    <div id="albumTableContainer">
      <h3 id="countryName">Albums</h3>
      <table id="albumTable">
        <thead>
          <tr>
            <th>Title</th>
            <th>Publication Date</th>
            <th>Length</th>
          </tr>
        </thead>
        <tbody id="albumList">
          <!-- Album rows will be populated here -->
        </tbody>
      </table>
    </div>

    <svg id="scene">
      <!-- <g id="links"></g>
      <g id="labels"></g>
      <g id="nodes"></g> -->
    </svg>

    <script>
      // const getCountryISO2 = require("country-iso-3-to-2");

      let width = 1250,
        height = 1050,
        svg = d3.select("#scene").attr("width", width).attr("height", height);

      let projection = d3
        .geoMercator()
        .scale(200)
        .translate([width / 2, height / 2]);

      // Load external data
      Promise.all([
        d3.json("data/custom.geo.json"),
        d3.csv(
          // "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world_population.csv"
          "data/wasabi_albums_pre-processed.csv"
        ),
      ]).then((files) => {
        const groupedByCountry = files[1].reduce((accumulator, record) => {
          if (!accumulator[record.country]) {
            accumulator[record.country] = [];
          }
          accumulator[record.country].push(record);
          return accumulator;
        }, {});

        const counts = Object.values(groupedByCountry);
        const minCount = Math.min(...counts);
        const maxCount = Math.max(...counts);

        const numThresholds = 6; // 7 colors => 6 thresholds
        const step = (maxCount - minCount) / numThresholds;
        const domain = Array.from(
          { length: numThresholds },
          (_, i) => minCount + i * step
        );

        let topo = files[0],
          data = files[1];
        let colorScale = d3
          .scaleThreshold()
          // .domain(domain)
          .domain([1, 10, 100, 1000, 10000, 100000])
          .range(d3.schemeBlues[7]);

        // create a tooltip
        var Tooltip = d3
          .select("body")
          .append("div")
          .style("opacity", 0)
          .attr("class", "tooltip")
          .style("background-color", "white")
          .style("border", "solid")
          .style("border-width", "2px")
          .style("border-radius", "5px")
          .style("padding", "5px");

        function updateAlbumTable(countryName, albums) {
          // Set country name as table title
          d3.select("#countryName").text(`Albums from ${countryName}`);

          // Populate the table
          let tbody = d3.select("#albumList");
          tbody.html(""); // Clear existing rows

          albums.forEach((album) => {
            let row = tbody.append("tr");
            row.append("td").text(album.title);
            row.append("td").text(album.publicationDate || "Unknown");
            row.append("td").text(album.length || "Unknown");
          });
        }

        // Three function that changes the tooltip when user hover / move / leave a cell
        var mouseover = function (d) {
          Tooltip.style("opacity", 1);
          d3.select(this).style("stroke", "black").style("opacity", 1);

          // Fetch albums and update the table
          let albums = getValue(d.properties);
          updateAlbumTable(d.properties.name, albums);
        };

        var mousemove = function (d) {
          // Get the correct value for the current country
          let value = getValue(d.properties).length;

          Tooltip.html(value + " albums")
            .style("left", d3.event.pageX + 10 + "px")
            .style("top", d3.event.pageY - 28 + "px");
        };

        var mouseleave = function (d) {
          Tooltip.style("opacity", 0);
          d3.select(this).style("stroke", "none").style("opacity", 0.8);
        };

        // Draw the map
        svg
          .append("g")
          .selectAll("path")
          .data(topo.features)
          .enter()
          .append("path") // draw each country
          .attr("d", d3.geoPath().projection(projection))
          // set the color of each country according to the value in the csv data
          .attr("fill", (d) => {
            return colorScale(getValue(d.properties));
          })
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave);

        function getValue(countryId) {
          return (
            groupedByCountry[countryId.fips_10] ||
            groupedByCountry[countryId.iso_a2] ||
            groupedByCountry[countryId.iso_a2_eh] ||
            groupedByCountry[countryId.wb_a2] ||
            []
          );
        }
      });
    </script>
  </body>
</html>
